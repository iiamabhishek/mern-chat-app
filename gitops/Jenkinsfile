pipeline {
    agent any

    environment {
        DOCKER_USER = 'iiamabhishek05'
        AWS_DEFAULT_REGION = 'ap-south-1'
        TF_CHANGES = "false"
        TF_DIR = 'terraform'
        // ENV_NAME = 'prod'
        // TF_VAR_environment = "${ENV_NAME}"
        // TF_VAR_app_version = "${params.PARENT_BUILD_NUMBER}"
        // TF_VAR_aws_region = "${AWS_DEFAULT_REGION}"
        // TF_VAR_cluster_name = 'mern-cluster'
    }

    stages {

        stage('Clean the Workspace') {
            steps {
                cleanWs()        
            }
        }

        stage('Clone Repository') {
            steps {
                git branch: 'master',
                url: 'https://github.com/iiamabhishek/mern-chat-app.git',
                credentialsId: 'github'
            }
        }

        stage('Verify Parameters') {
            steps {
                script {
                    if (!params.PARENT_BUILD_NUMBER) {
                        error "PARENT_BUILD_NUMBER parameter is missing!"
                    } else {
                        echo "âœ… Received PARENT_BUILD_NUMBER: ${params.PARENT_BUILD_NUMBER}"
                    }
                }
            }
        }

        stage('Update Kubernetes Image Tags') {
            steps {
                script {
                    dir('kubernetes') {
                        def tag = params.PARENT_BUILD_NUMBER

                        // Update backend image tag
                        sh "sed -i 's|iiamabhishek05/mern-app-backend:.*|iiamabhishek05/mern-app-backend:v${tag}|' backend-deployment.yaml"

                        // Update frontend image tag
                        sh "sed -i 's|iiamabhishek05/mern-app-frontend:.*|iiamabhishek05/mern-app-frontend:v${tag}|' frontend-deployment.yaml"

                        echo "âœ… Image tags updated to v${tag}"
                    }
                }
            }
        }

        stage('Push Updated Kubernetes Manifests to GitHub') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'github', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD')]) {
                        sh """
                            git config user.name "${GIT_USERNAME}"
                            git config user.email "${GIT_USERNAME}@users.noreply.github.com"

                            git pull https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/iiamabhishek/mern-chat-app.git master

                            git add *.yaml

                            # Check if there are any staged changes
                            if ! git diff --cached --quiet; then
                                git commit -m "Update Kubernetes image tags to v${params.PARENT_BUILD_NUMBER}"
                                git push https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/iiamabhishek/mern-chat-app.git HEAD:master
                                echo "âœ… Changes committed and pushed!"
                            else
                                echo "â„¹ï¸ No changes to push."
                            fi
                        """
                    }
                }
            }
        }

        stage('Terraform Init & Validate') {
            steps {
                dir("${TF_DIR}") {
                        sh 'rm -rf .terraform terraform.tfstate* tfplan'
                        sh 'terraform init -backend=true -input=false -no-color'
                        sh 'terraform validate'
                    }
                }
            }
        }

        stage('Terraform Plan') {
            steps {
                dir("${TF_DIR}") {
                    script {
                        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding',credentialsId: 'aws-creds',accessKeyVariable: 'AWS_ACCESS_KEY_ID',secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
                            
                            echo "ðŸ”„ Running terraform plan..."
                            // Run terraform plan and save the exit code to a file
                            sh '''
                                terraform plan -detailed-exitcode -out=tfplan
                                echo $? > plan_exit_code.txt
                            '''

                            // Read the exit code from file
                            def exitCodeStr = readFile('plan_exit_code.txt').trim()
                            echo "ðŸ§ª Raw exit code: ${exitCodeStr}"

                            def exitCode = exitCodeStr.toInteger()
                            echo "ðŸ”¢ Parsed exit code as Integer: ${exitCode}"

                            if (exitCode == 2) {
                                currentBuild.description = "Terraform: Changes Detected"
                                echo "âš ï¸  Changes detected"
                                // Set TF_CHANGES using Groovy/Env syntax
                                env.TF_CHANGES = "true"
                            } else if (exitCode == 0) {
                                echo "âœ… No infrastructure changes"
                                env.TF_CHANGES = "false"
                            } else {
                                error "âŒ Terraform plan failed"
                            }

                            // Optional: archive plan for inspection
                            archiveArtifacts artifacts: 'tfplan', fingerprint: true
                        }
                    }
                }
            }
        }

        stage('Terraform Apply') {
            when {
                expression { 
                    return env.TF_CHANGES == "true" 
                }
            }
            steps {
                dir("${TF_DIR}") {
                    script {
                        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding',credentialsId: 'aws-creds',accessKeyVariable: 'AWS_ACCESS_KEY_ID',secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
                            timeout(time: 15, unit: 'MINUTES') {
                                def approval = input(
                                    message: 'Apply Terraform changes?',
                                    parameters: [
                                        string(name: 'Justification', description: 'Why are we applying this?')
                                    ]
                                )
                                echo "Approved by reason: ${approval}"
                                sh 'terraform apply -auto-approve tfplan'
                            }
                        }
                    }
                }
            }
        }

        stage('Terraform No Changes') {
            when {
                expression { return env.TF_CHANGES == "false" }
            }
            steps {
                dir("${TF_DIR}") {
                    echo "âœ… No infrastructure changes to apply."
                    sh 'terraform show tfplan || echo "No tfplan file found."'
                }
            }
        }
        // stage('Terraform Init & Validate') {
        //     steps {
        //         dir('terraform') {
        //             script {
        //                 withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
        //                     // Initialize Terraform
        //                     sh 'terraform init -backend=true -input=false -no-color'
        //                     def validateOutput = sh(
        //                         script: 'terraform validate -json',
        //                         returnStdout: true
        //                     )
        //                     echo "Validation output: ${validateOutput}"
        //                 }
        //             }
        //         }
        //     }
        // }

        // stage('Terraform Plan') {
        //     steps {
        //         dir('terraform') {
        //             script {
        //                 withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
        //                     def planCmd = """
        //                         terraform plan -detailed-exitcode \\
        //                         -out=tfplan \\
        //                         -var "environment=\${env.ENV_NAME}" \\
        //                         -var "app_version=\${params.PARENT_BUILD_NUMBER}"
        //                     """
        //                     def exitCode = sh(
        //                         script: "${planCmd} || true",
        //                         returnStatus: true
        //                     )
        //                     echo "Terraform Plan Exit Code: ${exitCode}"
        //                     env.TF_CHANGES = (exitCode == 2).toString()
        //                     archiveArtifacts artifacts: 'tfplan', fingerprint: true
        //                 }
        //             }
        //         }
        //     }
        // }

        // stage('Terraform Apply') {
        //     when {
        //         expression {
        //             env.TF_CHANGES == "true" &&
        //             env.BRANCH_NAME == 'master'
        //         }
        //     }
        //     steps {
        //         dir('terraform') {
        //             script {
        //                 timeout(time: 30, unit: 'MINUTES') {
        //                     withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
        //                         def approval = input(
        //                             message: 'Confirm Terraform changes:',
        //                             parameters: [
        //                                 string(name: 'REASON', description: 'Change justification')
        //                             ]
        //                         )
        //                         sh 'terraform apply -auto-approve tfplan'
        //                         echo "âœ… Terraform applied with justification: ${approval.REASON}"
        //                     }
        //                 }
        //             }
        //         }
        //     }
        // }
    

        // stage('Post Apply Audit') {
        //     when {
        //         expression { env.TF_CHANGES == "true" }
        //     }
        //     steps {
        //         dir('terraform') {
        //             script {
        //                 // Save state and resource summary
        //                 sh '''
        //                     terraform show -json > tfstate.json
        //                     terraform state list > resource-list.txt
        //                 '''

        //                 // Archive for audit/tracking
        //                 archiveArtifacts artifacts: 'tfstate.json, resource-list.txt', fingerprint: true

        //                 // Optional: Print summary
        //                 echo "âœ… Terraform resources applied:"
        //                 sh 'cat resource-list.txt'
        //             }
        //         }
        //     }
        // }

        // stage('Backup Kubernetes Resources') {
        //     steps {
        //         withKubeConfig([credentialsId: 'kubeconfig']) {
        //             sh '''
        //                 mkdir -p kube_backup
        //                 kubectl get all -o yaml > kube_backup/kubernetes-backup-$(date +%F-%H-%M).yaml
        //                 echo "âœ… Kubernetes backup created!"
        //             '''
        //         }
        //     }
        // }

        // stage('Apply Kubernetes Manifests') {
        //     steps {
        //         script {
        //             dir('kubernetes') {
        //                 withKubeConfig([credentialsId: 'kubeconfig']) {
        //                     sh '''
        //                         kubectl get pod
        //                         kubectl apply -f .
                                
        //                         echo "âœ… Kubernetes Menifest File applied successfully!"
        //                     '''
        //                 }
        //             }
        //         }
        //     }
        // }

        // stage('Docker Cleanup local images') {
        //     steps {
        //         sh """
        //             docker rmi $DOCKER_USER/mern-app-frontend:v${params.PARENT_BUILD_NUMBER}
        //             docker rmi $DOCKER_USER/mern-app-backend:v${params.PARENT_BUILD_NUMBER}
        //         """
        //     }
        // }
    }
    // post {
    //     always {
    //         dir('terraform') {
    //             script {
    //                 sh 'rm -f tfplan || true'
    //                 sh 'terraform output -json > outputs.json'
    //                 archiveArtifacts artifacts: 'outputs.json'
    //             }
    //         }
    //     }
    //     failure {
    //         script {
    //             emailext body: 'Terraform deployment failed. Build URL: ${BUILD_URL}',
    //                     subject: 'FAILED: ${JOB_NAME}',
    //                     to: 'devops@example.com'
    //         }
    //     }
    // }
}